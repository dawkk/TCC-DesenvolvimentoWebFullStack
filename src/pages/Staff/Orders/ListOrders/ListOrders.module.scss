.GridMainContainer {
  display: flex;
}

.ButtonStatusSelect {
  margin-right: 1rem;
  margin: 0.5rem 1rem 0.5rem 0.5rem
}

.GridContainerOrders {
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 0.5rem;
  padding: 1rem;
  box-sizing: border-box;
  margin-bottom: 4rem;
}

.TypographyBorderBottom {
  border-bottom: 1px solid #f0f0f0;
  padding-bottom: 0.5rem;
  margin-bottom: 1rem;
}

.GridCard {
  border-radius: 0.5rem;
}

.OrdersTitle {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 1rem;
  text-align: center;
  margin: 2rem 0 1rem 0;
}

.GridOrders {
  margin-bottom: 1rem;
  background-color: white;
  border-radius: 0.5rem;
}


.GridOrderProperties {
  margin-right: 1rem;
}


.PopOverList {
  border: none;
  box-shadow: none;
  padding: 0;
}



.PendingButton {
  color: #d46b08;
  background: #fff7e6;
  border: 1px solid #d9d9d9;
  text-align: center;
  border-radius: 0.5rem;
  padding: 0.2rem;
  box-sizing: border-box;
  width: 100px;
  margin-bottom: 0.4rem;
  cursor: pointer;
  transition: background-color 0.3s ease;
  &:hover {
    background-color: darken(#fff7e6, 15%);
  }
}

.PreparingButton {
  background: #e4bc47;
  color: #8a8c00;
}

.DeliveryButton {
  background: #ffb366;
  color: #8c4e00;
}

.CompleteButton {
  background: #4caf50;
  color: #ffffff;
}

.CancelledButton {
  background: #ff4d4f;
  color: #ffffff;
}


/* Component before changes, it works, but if there are more than 2 components in the list it only works for the order._id in the end


import { Box, Button, Card, CardContent, FormControl, Grid, List, ListItem, ListItemText, MenuItem, Paper, Popover, Select, Typography } from "@mui/material";
import IUserOrderDetails from "../../../../interfaces/IUserOrderDetails";
import { useEffect, useState } from "react";
import http from "../../../../api/axios";
import styles from './Dashboard.module.scss'
import IOrderStatus from '../../../../interfaces/IOrderStatus'


const Dashboard = () => {
  const [orders, setOrders] = useState<IUserOrderDetails[]>([]);
  const [orderStatuses, setOrderStatuses] = useState<IOrderStatus[]>([]);
  const [selectedStatus, setSelectedStatus] = useState<string>('');
  const [selectedStatusTitle, setSelectedStatusTitle] = useState("Pedidos Pendentes");
  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null);
  const [isLoading, setIsLoading] = useState(false);


  const open = Boolean(anchorEl);
  const id = open ? 'status-popover' : undefined;


  const fetchOrders = async () => {
    try {
      setIsLoading(true);
      const response = await http.get<IUserOrderDetails[]>('/orders');
      const allOrders = response.data.map(order => ({
        ...order,
        dateOrdered: order.dateOrdered ? new Date(order.dateOrdered) : undefined,
        updatedAt: order.updatedAt ? new Date(order.updatedAt) : undefined,
      }));
      const filteredOrders = selectedStatus !== ''
        ? allOrders.filter(order => order.status?.status === selectedStatus)
        : allOrders;
      const sortedOrders = filteredOrders.sort((a, b) => {
        const dateA = a.dateOrdered || new Date(0);
        const dateB = b.dateOrdered || new Date(0);
        return dateA.getTime() - dateB.getTime();
      });
      setOrders(sortedOrders);
    } catch (error) {
      console.error('Error fetching orders:', error);
    } finally {
      setIsLoading(false); // Reset loading state to false
    }
  };


  useEffect(() => {
    fetchOrders();
  }, [selectedStatus]);

  useEffect(() => {
    const fetchOrderStatuses = async () => {
      try {
        const response = await http.get('/orders/status');
        setOrderStatuses(response.data);
      } catch (error) {
        console.error('Error fetching order statuses:', error);
      }
    };
    fetchOrderStatuses();
  }, []);

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const handleClick = (event: any) => {
    setAnchorEl(event.currentTarget);
  };

  const handleStatusClick = (status: string) => {
    setSelectedStatus(status);
    setSelectedStatusTitle(status);
    setAnchorEl(null);
    setIsLoading(true);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleAccept = async (orderId: string, selectedStatusId: string) => {
    try {
      console.log('handleAccept orderID', orderId, 'handleAccept orderID', orderId)
      const response = await http.put(`/orders/${orderId}`, { status: selectedStatusId });
      
      console.log('handleAccept response', response.data)
      await fetchOrders();
    } catch (error) {
      console.error('Error updating order status:', error);
    }
  };




  const getButtonTypographyStyle = (status: string | undefined) => {
    switch (status) {
      case 'Pending':
        return styles.PendingButton;
      case 'Iniciando Preparo':
        return styles.PreparingButton;
      case 'Delivery a caminho':
        return styles.DeliveryButton;
      case 'Completo':
        return styles.CompleteButton;
      case 'Cancelado':
        return styles.CancelledButton;
      default:
        return styles.DefaultButton;
    }
  };

  return (
    <Box className={styles.GridMainContainer}>
      <Grid container className={styles.GridContainerOrders}>
        {orderStatuses.map((status: IOrderStatus) => (
          <Grid item key={status._id}>
            <Button variant='contained' className={styles.ButtonStatusSelect} onClick={() => handleStatusClick(status.status)}
              disabled={isLoading}
            >
              {status.status}
            </Button>
          </Grid>
        ))}
        <Grid item xs={8}>
          <Paper>
            <Typography variant="h4" className={styles.OrdersTitle}>
              {selectedStatusTitle}
            </Typography>
          </Paper>
        </Grid>
        {orders.map((order) => (
          <Grid item xs={8} key={order._id} className={styles.GridOrders}>
            <Card variant="outlined" sx={{ borderRadius: "0.5rem" }}>
              <CardContent>
                <Typography variant="h6" sx={{ borderBottom: "1px solid #f0f0f0", pb: 1, mb: 2 }}>
                  {order._id}
                </Typography>

                <Typography
                  className={`${styles.PendingButton} ${getButtonTypographyStyle(order.status?.status)}`}
                >
                  {order.status?.status}
                </Typography>
                <Button></Button>

                <Popover
                  id={id}
                  open={open}
                  anchorEl={anchorEl}
                  onClose={handleClose}
                  anchorOrigin={{
                    vertical: 'bottom',
                    horizontal: 'left',
                  }}
                  transformOrigin={{
                    vertical: 'top',
                    horizontal: 'left',
                  }}
                >
                  <List className={styles.PopOverList}>
                    {orderStatuses.map((status: IOrderStatus) => (
                      <ListItem
                        key={status._id}
                        button
                        onClick={() => handleAccept(order._id, status._id)}
                      >
                        <ListItemText primary={status.status} />
                      </ListItem>
                    ))}
                  </List>
                </Popover>



                <Typography>Criação do Pedido: {order.dateOrdered?.toLocaleString()}</Typography>
                <Typography sx={{ borderBottom: "1px solid #f0f0f0", pb: 1, mb: 1 }}>Total R$ {order.totalAmount}</Typography>
                {order.cartItems?.map((cartItem) => (
                  <Box key={cartItem._id} sx={{ borderBottom: "1px solid #f0f0f0", pb: 1, mb: 2 }}>
                    <Typography>{cartItem.dishId?.title}</Typography>
                    <Typography>Quantidade {cartItem.quantity}</Typography>
                    <Typography>R$ {cartItem.dishId?.price}</Typography>
                  </Box>
                ))}
                <Typography>{order.userId?.firstName}, {order.userId?.lastName}</Typography>
                <Typography>
                  Endereço de entrega: {order.deliveryAddress?.street}, {order.deliveryAddress?.number},
                  {order.deliveryAddress?.neighborhood}, {order.deliveryAddress?.additionalInfo}
                </Typography>

              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

    </Box >
  )
}

export default Dashboard;

*/